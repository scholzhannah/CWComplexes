import Mathlib.Topology.IsLocalHomeomorph
import Mathlib.Topology.Homotopy.HomotopyGroup
import Mathlib.Topology.Sets.Compacts
import Mathlib.Topology.MetricSpace.Isometry
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.Data.Fintype.Lattice

/-!
# Auxiliary lemmas and definitions

In this file we have auxiliary lemmas that are not in mathlib but do not have any direct relation
to CW-complexes.
They are sorted by topics.
At the bottom of the file there are lemmas that are not used in this project but relate to
definitions and lemmas in this file.
-/

noncomputable section

/-! ### Basic logic and set theory-/

-- it looks like I should rewrite anything that needs this anyways
-- generalization?
--needed in this file
lemma inter_eq_inter_iff_compl {X : Type*} {A B C : Set X} : A ‚à© B = C ‚à© B ‚Üî A·∂ú ‚à© B = C·∂ú ‚à© B := by
  constructor <;> (intro; simp_all [Set.ext_iff, not_iff_not])

--needed in product file
lemma Set.subset_product {Œ± Œ≤ : Type*} {s : Set (Œ± √ó Œ≤)} :
    s ‚äÜ (Prod.fst '' s) √óÀ¢ (Prod.snd '' s) :=
  fun _ hp ‚Ü¶ mem_prod.2 ‚ü®mem_image_of_mem _ hp, mem_image_of_mem _ hp‚ü©

/-! ### Different maps -/

-- needed in this file and in examples file
/-- `Function.const` as a `PartialEquiv`.
  It consists of two constant maps in opposite directions. -/
def PartialEquiv.single {X Y : Type*} (x : X) (y : Y) : PartialEquiv X Y where
  toFun := Function.const X y
  invFun := Function.const Y x
  source := {x}
  target := {y}
  map_source' := fun _ _ ‚Ü¶ by rfl
  map_target' := fun _ _ ‚Ü¶ by rfl
  left_inv' := fun x' x'mem  ‚Ü¶ by rw [Set.eq_of_mem_singleton x'mem]; rfl
  right_inv' := fun y' y'mem ‚Ü¶ by rw [Set.eq_of_mem_singleton y'mem]; rfl

/-! ### Topology -/

-- probably not needed after refactor of kspace
-- needed in kification file
/-- This lemma states that a set `A` is open in a set `B` iff `A·∂ú` is closed in `B`.-/
lemma open_in_iff_compl_closed_in {X : Type*} [TopologicalSpace X] {A B : Set X} :
    (‚àÉ (C : Set X), IsOpen C ‚àß A ‚à© B = C ‚à© B) ‚Üî
    ‚àÉ (C : Set X), IsClosed C ‚àß A·∂ú ‚à© B = C ‚à© B := by
  constructor
  ¬∑ intro ‚ü®C, openC, hC‚ü©
    use C·∂ú
    rw [inter_eq_inter_iff_compl, compl_compl, compl_compl]
    exact ‚ü®isClosed_compl_iff.2 openC, hC‚ü©
  ¬∑ intro ‚ü®C, closedC, hC‚ü©
    use C·∂ú
    rw [inter_eq_inter_iff_compl, compl_compl]
    exact ‚ü®isOpen_compl_iff.2 closedC, hC‚ü©

-- needed in examples file
lemma affineHomeomorph_trans {ùïú : Type*} [Field ùïú] [NoZeroDivisors ùïú] [TopologicalSpace ùïú]
    [TopologicalRing ùïú] (a b c d : ùïú) (h1 : a ‚â† 0) (h2 : c ‚â† 0) :
    (affineHomeomorph a b h1).trans (affineHomeomorph c d h2) =
    affineHomeomorph (c * a) (c * b + d) (mul_ne_zero h2 h1)  := by
  ext
  simp_rw [Homeomorph.trans_apply, affineHomeomorph_apply]
  ring
