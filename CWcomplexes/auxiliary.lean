import Mathlib.Topology.IsLocalHomeomorph
import Mathlib.Topology.Homotopy.HomotopyGroup
import Mathlib.Topology.Sets.Compacts
import Mathlib.Topology.MetricSpace.Isometry
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.Data.Fintype.Lattice

/-!
# Auxiliary lemmas and definitions

In this file we have auxiliary lemmas that are not in mathlib but do not have any direct relation
to CW-complexes.
They are sorted by topics.
At the bottom of the file there are lemmas that are not used in this project but relate to
definitions and lemmas in this file.
-/

noncomputable section

/-! ### Basic logic and set theory-/

lemma biSup_lt_eq_iSup {X Y : Type*} [LT X] [NoMaxOrder X] (I : X ‚Üí Set Y) :
    ‚®Ü (x : X) (x' < x), I x' = ‚®Ü x, I x := by
  apply le_antisymm
  ¬∑ exact iSup_le fun _ ‚Ü¶ iSup_le fun _ ‚Ü¶ iSup_le fun _ ‚Ü¶ le_iSup _ _
  ¬∑ apply iSup_le (fun x ‚Ü¶ ?_)
    obtain ‚ü®x', xlt‚ü© := exists_gt x
    exact le_iSup_of_le x' (le_iSup_of_le x (le_iSup_of_le xlt (le_refl _)))

lemma biInf_lt_eq_iInf {X Y : Type*} [LT X] [NoMaxOrder X] (I : X ‚Üí Set Y) :
    ‚®Ö (x : X) (x' < x), I x' = ‚®Ö x, I x := by
  apply le_antisymm
  ¬∑ apply le_iInf (fun x ‚Ü¶ ?_)
    obtain ‚ü®x', xlt‚ü© := exists_gt x
    apply iInf_le_of_le x' (iInf_le_of_le x (iInf_le_of_le xlt (le_refl _)))
  ¬∑ exact le_iInf fun _ ‚Ü¶ le_iInf fun _ ‚Ü¶ le_iInf fun _ ‚Ü¶ iInf_le _ _

-- is this needed?
lemma biUnion_lt_eq_iUnion {X : Type*} (I : ‚Ñï ‚Üí Set X) :
  ‚ãÉ (n : ‚Ñï) (m < n), I m  = ‚ãÉ (n : ‚Ñï), I n := biSup_lt_eq_iSup _

-- is this needed?
lemma biInter_lt_eq_iInter {X : Type*} (I : ‚Ñï ‚Üí Set X) :
  ‚ãÇ (n : ‚Ñï) (m < n), I m  = ‚ãÇ (n : ‚Ñï), I n := biInf_lt_eq_iInf _

-- needed in constructions file
-- in mathlib
lemma Set.iUnion_sum {X Y Z: Type*} {f : X ‚äï Y ‚Üí Set Z} :
    ‚ãÉ x : X ‚äï Y, f x = (‚ãÉ x : X, f (.inl x)) ‚à™ ‚ãÉ x : Y, f (.inr x) := by
  ext; simp

--needed in this file
lemma inter_eq_inter_iff_compl {X : Type*} {A B C : Set X} : A ‚à© B = C ‚à© B ‚Üî A·∂ú ‚à© B = C·∂ú ‚à© B := by
  constructor <;> (intro; simp_all [Set.ext_iff, not_iff_not])

--needed in product file
lemma Set.subset_product {Œ± Œ≤ : Type*} {s : Set (Œ± √ó Œ≤)} :
    s ‚äÜ (Prod.fst '' s) √óÀ¢ (Prod.snd '' s) :=
  fun _ hp ‚Ü¶ mem_prod.2 ‚ü®mem_image_of_mem _ hp, mem_image_of_mem _ hp‚ü©

-- needed in product file
lemma exists_iff_and_of_monotone {L : Type*} [SemilatticeSup L] {P Q : L ‚Üí Prop}
    (monP : Monotone P) (monQ : Monotone Q):
    (‚àÉ i, P i ‚àß Q i) ‚Üî (‚àÉ i, P i) ‚àß ‚àÉ i, Q i :=
  ‚ü®fun ‚ü®i, hP, hQ‚ü© ‚Ü¶ ‚ü®‚ü®i, hP‚ü©, ‚ü®i, hQ‚ü©‚ü©,
    fun ‚ü®‚ü®i, hP‚ü©, ‚ü®j, hQ‚ü©‚ü© ‚Ü¶ ‚ü®i ‚äî j, ‚ü®monP le_sup_left hP,  monQ le_sup_right hQ‚ü©‚ü©‚ü©

/-! ### ENat-/

-- needed in definition file
lemma ENat.add_one_pos {n : ‚Ñï‚àû} : 0 < n + 1 := by
  rw [‚Üê ENat.one_le_iff_pos]
  exact le_add_self

-- needed in definition file
lemma ENat.add_finite_lt_add_finite_right {n m k : ‚Ñï‚àû} (ne : k ‚â† ‚ä§) : n + k < m + k ‚Üî n < m := by
  cases' k with k
  ¬∑ contradiction
  cases' n with n
  ¬∑ simp
  cases' m with m
  ¬∑ norm_cast; simp [ENat.coe_lt_top, -Nat.cast_add]
  ¬∑ norm_cast; simp_all

/-! ### Different maps -/

-- needed in this file and in examples file
/-- `Function.const` as a `PartialEquiv`.
  It consists of two constant maps in opposite directions. -/
def PartialEquiv.single {X Y : Type*} (x : X) (y : Y) : PartialEquiv X Y where
  toFun := Function.const X y
  invFun := Function.const Y x
  source := {x}
  target := {y}
  map_source' := fun _ _ ‚Ü¶ by rfl
  map_target' := fun _ _ ‚Ü¶ by rfl
  left_inv' := fun x' x'mem  ‚Ü¶ by rw [Set.eq_of_mem_singleton x'mem]; rfl
  right_inv' := fun y' y'mem ‚Ü¶ by rw [Set.eq_of_mem_singleton y'mem]; rfl

-- needed in this file
/-- `Equiv.piCongrLeft` as an `IsometryEquiv`: this is the natural
`‚àÄ i, Y i ‚âÉ·µ¢ ‚àÄ j, Y (e.symm j)` obtained from a bijection `Œπ ‚âÉ Œπ'` of finite types.-/
def IsometryEquiv.piCongrLeftofFintype' {Œπ Œπ' : Type*} [Fintype Œπ] [Fintype Œπ'] {Y : Œπ ‚Üí Type*}
    [‚àÄ j, PseudoEMetricSpace (Y j)]
    (e : Œπ ‚âÉ Œπ') : (‚àÄ i, Y i) ‚âÉ·µ¢ ‚àÄ j, Y (e.symm j) := IsometryEquiv.mk (Equiv.piCongrLeft' _ e)
  (by
    intro x1 x2
    simp_rw [PseudoEMetricSpace.toEDist, pseudoEMetricSpacePi, instEDistForall,
      Finset.sup_univ_eq_iSup]
    exact (Equiv.iSup_comp (g := fun b ‚Ü¶ edist (x1 b) (x2 b)) e.symm))

-- needed in this file
/-- `Equiv.piCongrLeft` as an `IsometryEquiv`: this is the natural
`‚àÄ i, Y (e i) ‚âÉ·µ¢ ‚àÄ j, Y j` obtained from a bijection `Œπ ‚âÉ Œπ'` of finite types.-/
def IsometryEquiv.piCongrLeftofFintype {Œπ Œπ' : Type*} [Fintype Œπ] [Fintype Œπ'] {Y : Œπ' ‚Üí Type*}
    [‚àÄ j, PseudoEMetricSpace (Y j)]
    (e : Œπ ‚âÉ Œπ') : (‚àÄ i, Y (e i)) ‚âÉ·µ¢ ‚àÄ j, Y j := (piCongrLeftofFintype' e.symm).symm

-- needed in this file
/-- An equivalence `Œπ ‚âÉ Œπ'` of finite types yields the `IsometryEquiv` `(Œπ ‚Üí X) ‚âÉ·µ¢ (Œπ' ‚Üí X)`. -/
def IsometryEquiv.arrowCongrLeftofFintype {Œπ Œπ' X : Type*} [Fintype Œπ] [Fintype Œπ']
    [PseudoEMetricSpace X] (e : Œπ ‚âÉ Œπ') : (Œπ ‚Üí X) ‚âÉ·µ¢ (Œπ' ‚Üí X) :=
  piCongrLeftofFintype (Y := fun _ ‚Ü¶ X) e

-- needed in this file
/-- `Equiv.sumArrowEquivProdArrow` as an `IsometryEquiv`.-/
def IsometryEquiv.sumArrowEquivProdArrowofFintype (Œ± Œ≤ Œ≥ : Type*) [Fintype Œ±] [Fintype Œ≤]
    [PseudoEMetricSpace Œ≥] : (Œ± ‚äï Œ≤ ‚Üí Œ≥) ‚âÉ·µ¢ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
  mk (Equiv.sumArrowEquivProdArrow _ _ _) (by
    intro f1 f2
    simp_rw [PseudoEMetricSpace.toEDist, Prod.pseudoEMetricSpaceMax, pseudoEMetricSpacePi,
      instEDistForall, Finset.sup_univ_eq_iSup, iSup_sum]
    rfl)

-- needed in product file
/-- The natural `IsometryEquiv` between `(Fin m ‚Üí X) √ó (Fin n ‚Üí X)` and `(Fin (m + n) ‚Üí X)`.-/
def IsometryEquiv.finArrowProdHomeomorphFinAddArrow {X : Type*} [PseudoEMetricSpace X] (m n : ‚Ñï) :
    (Fin m ‚Üí X) √ó (Fin n ‚Üí X) ‚âÉ·µ¢ (Fin (m + n) ‚Üí X) :=
  (sumArrowEquivProdArrowofFintype _ _ _).symm.trans (arrowCongrLeftofFintype finSumFinEquiv)

/-! ### Topology -/

lemma closedBall_eq_singleton_of_unique {X : Type*} [Unique X] [PseudoMetricSpace X] {Œµ : ‚Ñù}
    (h : 0 ‚â§ Œµ) : Metric.closedBall default Œµ = {default (Œ± := X)} := by
  ext
  simp [Unique.eq_default, h]

-- needed because this cannot be done by a rewrite
-- needed in examples file
lemma closedBall_zero_dim_singleton {X : Type*} [PseudoMetricSpace (Fin 0 ‚Üí X)] :
    (Metric.closedBall ![] 1 : Set (Fin 0 ‚Üí X)) = {![]} :=
  closedBall_eq_singleton_of_unique zero_le_one

lemma sphere_eq_empty_of_unique {X : Type*} [Unique X] [PseudoMetricSpace X] {Œµ : ‚Ñù} (h : 0 < Œµ) :
    (Metric.sphere default Œµ : Set X) = ‚àÖ := by
  simp [Metric.sphere, Unique.eq_default, ne_of_lt h]

-- needed in definition file and examples file
lemma sphere_zero_dim_empty {X : Type*} {h : PseudoMetricSpace (Fin 0 ‚Üí X)} :
    (Metric.sphere ![] 1 : Set (Fin 0 ‚Üí X)) = ‚àÖ := sphere_eq_empty_of_unique zero_lt_one

-- needed in kification file
/-- This lemma states that a set `A` is open in a set `B` iff `A·∂ú` is closed in `B`.-/
lemma open_in_iff_compl_closed_in {X : Type*} [TopologicalSpace X] {A B : Set X} :
    (‚àÉ (C : Set X), IsOpen C ‚àß  A ‚à© B = C ‚à© B) ‚Üî
    ‚àÉ (C : Set X), IsClosed C ‚àß  A·∂ú ‚à© B = C ‚à© B := by
  constructor
  ¬∑ intro ‚ü®C, openC, hC‚ü©
    use C·∂ú
    rw [inter_eq_inter_iff_compl, compl_compl, compl_compl]
    exact ‚ü®isClosed_compl_iff.2 openC, hC‚ü©
  ¬∑ intro ‚ü®C, closedC, hC‚ü©
    use C·∂ú
    rw [inter_eq_inter_iff_compl, compl_compl]
    exact ‚ü®isOpen_compl_iff.2 closedC, hC‚ü©

-- needed in constructions file and product file
lemma ContinuousOn.image_comp_continuous {Œ± Œ≤ Œ≥ : Type*} [TopologicalSpace Œ±] [TopologicalSpace Œ≤]
    [TopologicalSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : Set Œ±} (conton : ContinuousOn g (f '' s))
    (cont : Continuous f) : ContinuousOn (g ‚àò f) s :=
  conton.comp cont.continuousOn (s.mapsTo_image f)

-- needed in examples file
lemma affineHomeomorph_trans {ùïú : Type*} [Field ùïú] [NoZeroDivisors ùïú] [TopologicalSpace ùïú]
    [TopologicalRing ùïú] (a b c d : ùïú) (h1 : a ‚â† 0) (h2 : c ‚â† 0) :
    (affineHomeomorph a b h1).trans (affineHomeomorph c d h2) =
    affineHomeomorph (c * a) (c * b + d) (mul_ne_zero h2 h1)  := by
  ext
  simp_rw [Homeomorph.trans_apply, affineHomeomorph_apply]
  ring

-- needed in kification file
lemma T2Space.mono {X : Type*} {s t : TopologicalSpace X}
    (le : t ‚â§ s) [t2 : @T2Space X s] : @T2Space X t where
  t2 := by
    intro i j ne
    rw [t2Space_iff] at t2
    obtain ‚ü®u, v, openu, openv, huv‚ü© := t2 ne
    exact ‚ü®u, v, le _ openu, le _ openv, huv‚ü©

/-! ### Lemmas that I am not using but relate to things I have defined above -/

/-- The natural `Equiv` between `(Fin m ‚Üí X) √ó (Fin n ‚Üí X)` and `(Fin (m + n) ‚Üí X)`.-/
def Equiv.finArrowProdEQuivFinAddArrow {X : Type*} (m n : ‚Ñï) :
    (Fin m ‚Üí X) √ó (Fin n ‚Üí X) ‚âÉ (Fin (m + n) ‚Üí X) :=
  (sumArrowEquivProdArrow _ _ _).symm.trans (finSumFinEquiv.arrowCongr (Equiv.refl _))

/-- `Equiv.sumArrowEquivProdArrow` as a homeomorphism. The natural homeomoorphism
`(Œπ ‚äï Œπ' ‚Üí X) ‚âÉ‚Çú (Œπ ‚Üí X) √ó (Œπ' ‚Üí X)` -/
def Homeomorph.sumArrowEquivProdArrow {Œπ Œπ' X: Type*} [TopologicalSpace X]:
    (Œπ ‚äï Œπ' ‚Üí X) ‚âÉ‚Çú (Œπ ‚Üí X) √ó (Œπ' ‚Üí X)  where
  toEquiv := Equiv.sumArrowEquivProdArrow _ _ _
  continuous_toFun := by
    simp only [Equiv.sumArrowEquivProdArrow, Equiv.coe_fn_mk, continuous_prod_mk]
    continuity
  continuous_invFun := continuous_pi fun i ‚Ü¶ match i with
    | .inl i => by apply (continuous_apply _).comp' continuous_fst
    | .inr i => by apply (continuous_apply _).comp' continuous_snd

/-- An equivalence `Œπ ‚âÉ Œπ'` yields the homeomorphism `(Œπ ‚Üí X) ‚âÉ‚Çú (Œπ' ‚Üí X)`.-/
def Homeomorph.arrowCongrLeft {Œπ Œπ' X : Type*} [TopologicalSpace X] (e : Œπ ‚âÉ Œπ') :
    (Œπ ‚Üí X) ‚âÉ‚Çú (Œπ' ‚Üí X) :=
  piCongrLeft (Y := fun _ ‚Ü¶ X) e

/-- The natural homeomorphism between `(Fin m ‚Üí X) √ó (Fin n ‚Üí X)` and `(Fin (m + n) ‚Üí X)`.-/
def Homeomorph.finArrowProdHomeomorphFinAddArrow {X: Type*} [TopologicalSpace X] (m n : ‚Ñï) :
    (Fin m ‚Üí X) √ó (Fin n ‚Üí X) ‚âÉ‚Çú (Fin (m + n) ‚Üí X) :=
  (sumArrowEquivProdArrow).symm.trans (arrowCongrLeft finSumFinEquiv)
