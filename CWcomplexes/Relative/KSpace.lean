import Mathlib.Topology.Sets.Compacts
import Mathlib.Topology.Defs.Induced
import Mathlib.Topology.RestrictGen
import Mathlib.Topology.Compactness.CompactlyGeneratedSpace
import CWcomplexes.Auxiliary

open Set Set.Notation Topology

/-!
# Kspaces and the k-ification

In this file we will define k-spaces and the k-ification and prove basic properties about them.

## Main definitions
* `KSpace`: A k-space is a topological space in which a set `A` is open iff for every compact set
  `B`, the intersection `A ∩ B` is open in `B`.
* `instkification`: For a topological space `X` one can define another topology on `X` as follows:
  `A` is open iff for all compact sets `B`, the intersection `A ∩ B` is open in `B`.

## Main results
* `kspace_of_WeaklyLocallyCompactSpace`: every weakly locally compact space is a k-space
* `kspace_of_SequentialSpace`: every sequential space is a k-space
* `isCompact_iff_isCompact_in_kification`: The compact sets of a topological space and its
  k-ification agree.
* `kspace_kification`: The k-ification makes any space into a k-space.
* `kification_kspace_eq_self`: The k-ification of a k-space `X` preserves the topology on `X`.
* `continuous_kification_of_continuousOn_compact`: A map going to the k-ification of a topological
  space `X` is continuous if map going to `X` is continuous when restricted to every compact set.

## References
* [J. Munkres, *Topology*]
* <https://en.wikipedia.org/wiki/Compactly_generated_space>
-/

noncomputable section

/-! ### K-spaces-/

/-- A space is a KSpace if the topology is generated by the compact sets.-/
class KSpace  (X : Type*) [TopologicalSpace X] : Prop where
  /-- A space is a k-space if the topology is generated by the compact sets.-/
  restrictGenTopology : RestrictGenTopology (X := X) {K | IsCompact K}

namespace KSpace

variable {X : Type*} [TopologicalSpace X] [KSpace X]

/-- A set `A` in a k-space is open iff for every compact set `K`, the intersection `K ∩ A` is
  open in `K`.-/
lemma isOpen_iff (A : Set X) : IsOpen A ↔ ∀ K, IsCompact K → IsOpen (K ↓∩ A) :=
  RestrictGenTopology.isOpen_iff restrictGenTopology

/-- A set `A` in a k-space is closed iff for every compact set `K`, the intersection `K ∩ A` is
  closed in `K`.-/
lemma isClosed_iff (A : Set X) : IsClosed A ↔ ∀ K, IsCompact K → IsClosed (K ↓∩ A) :=
  RestrictGenTopology.isClosed_iff restrictGenTopology

/-- If every set `A` is open if for every compact `K` the intersection `K ∩ A` is open in `K`,
  then the space is a k-space. -/
lemma kspace_of_isOpen {X : Type*} [TopologicalSpace X]
    (h : ∀ (A : Set X), (∀ K, IsCompact K → IsOpen (K ↓∩ A)) → IsOpen A) : KSpace X where
  restrictGenTopology := {isOpen_of_forall_induced := h}

/-- If every set `A` is closed if for every compact `K` the intersection `K ∩ A` is closed in `K`,
  then the space is a k-space. -/
lemma kspace_of_isClosed {X : Type*} [TopologicalSpace X]
    (h : ∀ (A : Set X), (∀ K, IsCompact K → IsClosed (K ↓∩ A)) → IsClosed A) : KSpace X where
  restrictGenTopology := RestrictGenTopology.of_isClosed h

/-- Every weakly locally compact space is a k-space.-/
instance kspace_of_WeaklyLocallyCompactSpace {X : Type*} [TopologicalSpace X]
    [WeaklyLocallyCompactSpace X] : KSpace X where
  restrictGenTopology := RestrictGenTopology.isCompact_of_weaklyLocallyCompact

/-- Every sequential space is a k-space.-/
instance kspace_of_SequentialSpace {X : Type*} [TopologicalSpace X]
    [SequentialSpace X] : KSpace X where
  restrictGenTopology := RestrictGenTopology.isCompact_of_seq

lemma preimage_isOpen {X K : Type u} [TopologicalSpace X] [KSpace X] [TopologicalSpace K]
    [CompactSpace X] (s : Set X) (hs : (∀ (K : Type u) [TopologicalSpace K], [CompactSpace K] →
      ∀ (f : K → X), Continuous f → IsOpen (f ⁻¹' s))) :
    IsOpen s := by
  rw [isOpen_iff]
  intro K hK
  let _ : CompactSpace (Elem K) := isCompact_iff_compactSpace.mp hK
  exact hs (Elem K) Subtype.val continuous_subtype_val

lemma kspace_of_preimage_isOpen.{u} {X : Type u} [TopologicalSpace X]
    (h : ∀ (s : Set X), (∀ (K : Type u) [TopologicalSpace K], [CompactSpace K] →
      ∀ (f : K → X), Continuous f → IsOpen (f ⁻¹' s)) → IsOpen s) :
    KSpace X where
  restrictGenTopology := {
    isOpen_of_forall_induced := by
      intro s hs
      apply h s
      intro K _ _ f hf
      change IsOpen ((fun x ↦ ⟨f x, mem_image_of_mem f trivial⟩) ⁻¹' ((f '' univ) ↓∩ s))
      apply (hf.subtype_mk fun x ↦ mem_image_of_mem f trivial).isOpen_preimage
      exact hs (f '' univ) (CompactSpace.isCompact_univ.image hf)}

instance kspace_of_compactlyGeneratedSpace {X : Type*} [TopologicalSpace X]
    [CompactlyGeneratedSpace X] : KSpace X := by
  apply kspace_of_preimage_isOpen
  intro s h
  apply CompactlyGeneratedSpace.isOpen'
  intro K _ _ _ f hf
  exact h K f hf

instance compactlyGeneratedSpace_of_kspace_of_t2 {X : Type*} [TopologicalSpace X] [T2Space X]
    [KSpace X] : CompactlyGeneratedSpace X := by
  apply compactlyGeneratedSpace_of_isClosed_of_t2
  intro s hs
  rw [isClosed_iff]
  intro K hK
  specialize hs K hK
  rw [← Subtype.preimage_coe_inter_self]
  exact isClosed_in_of_isClosed hs

/-- A type synonym used for the k-ification of a topological space.-/
def kification (X : Type*) := X

/--For a topological space `X` the k-ification is defined as:
  `A` is open iff for all compact sets `B`, the intersection `A ∩ B` is open in `B`.-/
instance instkification {X : Type*} [TopologicalSpace X] : TopologicalSpace (kification X) where
  IsOpen A := ∀ (K : Set X), IsCompact K → IsOpen (K ↓∩ A)
  isOpen_univ := by simp
  isOpen_inter A B hA hB K hK := by
    specialize hA K hK
    specialize hB K hK
    exact hA.inter hB
  isOpen_sUnion s hs K hK := by
    rw [preimage_val_sUnion]
    apply isOpen_sUnion
    rintro _ ⟨u, hu, rfl⟩
    exact hs u hu K hK

/-- A set `A` is the k-ification is open iff for all compact sets `K`,
  the intersection `K ∩ A` is open in `K`.-/
lemma kification.isOpen_iff {X : Type*} [TopologicalSpace X] {A : Set (kification X)} :
    IsOpen (X := kification X) A ↔
    ∀ (K : Set X), IsCompact K → IsOpen (K ↓∩ A) := by
  rfl

/-- A set `A` is the k-ification is closed iff for all compact sets `K`,
  the intersection `K ∩ A` is closed in `K`.-/
lemma kification.isClosed_iff {X : Type*} [TopologicalSpace X] {A : Set (kification X)} :
    IsClosed (X := kification X) A ↔
    ∀ (K : Set X), IsCompact K → IsClosed (K ↓∩ A):= by
  rw [← isOpen_compl_iff, isOpen_iff]
  congrm ∀ (K : Set X), IsCompact K → ?_
  exact isOpen_compl_iff

/-- The map taking a space to its k-ification.-/
def tokification (X : Type*) : X ≃ kification X :=
  ⟨fun x ↦ x, fun x ↦ x, fun _ ↦ rfl, fun _ ↦ rfl⟩

lemma tokification_image {X : Type*} [TopologicalSpace X] (A : Set X) :
    tokification X '' A = (A : Set (kification X)) := by
  simp [tokification]

lemma tokification_symm_image {X : Type*} [TopologicalSpace X] (A : Set X) :
    (tokification X).symm '' A = A := by
  simp [tokification]

lemma continuous_fromkification {X : Type*} [t : TopologicalSpace X] :
    Continuous (tokification X).symm where
  isOpen_preimage A hA := by
    rw [kification.isOpen_iff]
    intros
    exact isOpen_induced hA

lemma isOpenMap_tokification {X : Type*} [t: TopologicalSpace X] : IsOpenMap (tokification X) := by
  intro A hA
  rw [kification.isOpen_iff]
  intro K hK
  simp [tokification, isOpen_induced hA]

/-- The k-ification is finer than the original topology.-/
lemma kification_le {X : Type*} [t : TopologicalSpace X] :
    (instkification : TopologicalSpace X) ≤ (t : TopologicalSpace X) := by
  rw [← continuous_id_iff_le]
  change Continuous (tokification X).symm
  exact continuous_fromkification

lemma isCompact_iff_isCompact_tokification_image {X : Type*} [TopologicalSpace X] (K : Set X) :
    IsCompact K ↔ IsCompact (tokification X '' K) := by
  constructor
  · intro hK
    rw [isCompact_iff_finite_subcover]
    intro ι U hU hKU
    simp_rw [kification.isOpen_iff] at hU
    choose U' hU' using hU
    have hKU' : K ⊆ ⋃ i, U' i K hK := by
      simp_rw [← inter_eq_left, inter_iUnion,
        Subtype.preimage_coe_eq_preimage_coe_iff.mp (hU' _ K hK).2, ← inter_iUnion, inter_eq_left]
      rw [tokification_image] at hKU
      exact hKU
    rcases (isCompact_iff_finite_subcover.1 hK) (fun i ↦ U' i K hK)
      (fun i ↦ (hU' i K hK).1) hKU' with ⟨ι', hι'⟩
    use ι'
    simp_rw [tokification_image, ← inter_eq_left, inter_iUnion,
      ← Subtype.preimage_coe_eq_preimage_coe_iff.mp (hU' _ K hK).2, ← inter_iUnion, inter_eq_left]
    exact hι'
  · intro hK
    simp only [tokification_image] at hK
    suffices IsCompact ((tokification X).symm '' K) by
      simpa [tokification_symm_image]
    exact hK.image continuous_fromkification

/-- The compact sets of a topological space and its k-ification agree.-/
lemma isCompact_iff_isCompact_in_kification {X : Type*} [TopologicalSpace X] (C : Set X) :
    IsCompact C ↔ IsCompact (X := kification X) C := by
  suffices IsCompact C ↔ IsCompact (tokification X '' C) by
    simpa only [tokification, Equiv.coe_fn_mk, Set.image_id']
  exact isCompact_iff_isCompact_tokification_image C

/-- The k-ification makes any space into a k-space.-/
instance kspace_kification {X : Type*} [TopologicalSpace X] : KSpace (kification X) where
  restrictGenTopology := {
    isOpen_of_forall_induced := by
      intro A h
      rw [kification.isOpen_iff]
      intro K hK
      obtain ⟨E, hE, hEA⟩ :=
        h (tokification X '' K) ((isCompact_iff_isCompact_tokification_image K).1 hK)
      rw [kification.isOpen_iff] at hE
      obtain ⟨F, openF, hF⟩ := hE K hK
      refine ⟨F, openF, ?_⟩
      rw [tokification_image] at hEA
      simp only [kification] at hEA
      rw [hF, hEA]}

/-- The k-ification preserves the topology of k-spaces.-/
lemma kification_kspace_eq_self {X :Type*} [t : TopologicalSpace X] [KSpace X] :
    t = instkification := by
  simp_rw [TopologicalSpace.ext_iff, instkification]
  intro s
  rw [KSpace.isOpen_iff]
  trivial

lemma from_kification_continuous_of_continuous {X Y : Type*} [tX : TopologicalSpace X]
    [tY : TopologicalSpace Y] (f : X → Y) (cont : Continuous f) :
    Continuous (X := kification X) f := by
  rw [continuous_def] at cont ⊢
  intro s opens
  exact (TopologicalSpace.le_def.1 kification_le) (f ⁻¹' s) (cont s opens)

lemma from_kification_continuousOn_of_continuousOn {X Y : Type*} [tX : TopologicalSpace X]
    [tY : TopologicalSpace Y] (f : X → Y) (s : Set X) (conton : ContinuousOn f s) :
    ContinuousOn (X := kification X) f s := by
  rw [continuousOn_iff'] at conton ⊢
  intro t opent
  rcases conton t opent with ⟨u, openu, usub⟩
  use u
  exact ⟨(TopologicalSpace.le_def.1 kification_le) u openu, usub⟩

lemma continuous_compact_to_kification {X Y : Type*} [tX : TopologicalSpace X]
    [tY : TopologicalSpace Y] [CompactSpace X] (f : X → Y) (cont : Continuous f) :
    Continuous (Y := kification Y) f := by
  simp_rw [continuous_iff_isClosed]
  intro s hs
  simp_rw [kification.isClosed_iff, isClosed_induced_iff,
    Subtype.preimage_val_eq_preimage_val_iff] at hs
  obtain ⟨t, ht, hst⟩ := hs (Set.range f) (isCompact_range cont)
  suffices IsClosed (f ⁻¹' (Set.range f ∩ s)) by
    simpa only [preimage_inter, preimage_range, univ_inter]
  rw [← hst, Set.preimage_inter, Set.preimage_range, Set.univ_inter]
  exact ht.preimage cont

lemma continuousOn_compact_to_kification {X Y : Type*} [tX : TopologicalSpace X]
    [tY : TopologicalSpace Y] {A : Set X} (compact : IsCompact A)
    (f : X → Y) (conton : ContinuousOn f A) : ContinuousOn (Y := kification Y) f A := by
  rw [continuousOn_iff_continuous_restrict] at conton ⊢
  have _ := isCompact_iff_compactSpace.1 compact
  exact continuous_compact_to_kification (A.restrict f) conton

lemma continuous_kification_of_continuousOn_compact {X Y : Type*} [tX : TopologicalSpace X]
    [tY : TopologicalSpace Y] (f : X → Y) (conton : ∀ (C : Set X), IsCompact C → ContinuousOn f C) :
    Continuous (X := kification X) (Y := kification Y) f := by
  have conton' :  ∀ (C : Set X), IsCompact C → ContinuousOn (Y := kification Y) f C :=
    fun C compactC ↦ continuousOn_compact_to_kification compactC f (conton C compactC)
  rw [continuous_def]
  intro V openV
  simp only [kification.isOpen_iff]
  intro C compactC
  specialize conton' C compactC
  rw [continuousOn_iff'] at conton'
  obtain ⟨U, openU, hU⟩ := conton' V openV
  suffices IsOpen (C ↓∩ (f ⁻¹' V ∩ C)) by
    rw [preimage_inter, Subtype.coe_preimage_self, inter_univ] at this
    exact this
  rw [hU, preimage_inter, Subtype.coe_preimage_self, inter_univ]
  exact isOpen_induced openU

lemma continuous_kification_of_continuous {X Y : Type*} [tX : TopologicalSpace X]
    [tY : TopologicalSpace Y] (f : X → Y) (cont : Continuous f) :
    @Continuous (kification X) (kification Y) instkification instkification f := by
  apply continuous_kification_of_continuousOn_compact
  intros
  exact cont.continuousOn

instance t2space_kification_of_t2space {X : Type*} [TopologicalSpace X] [a : T2Space X] :
  T2Space (kification X) := t2Space_antitone kification_le a
